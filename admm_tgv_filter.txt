% --- 1. 生成更复杂的测试数据 ---
N = 400;
% 一个平滑的正弦部分
t1 = linspace(0, 2*pi, 200)';
part1 = 2 * sin(t1);
% 一个阶跃部分
part2 = 3 * ones(200, 1);
part2(100:end) = -1;

z_true = [part1; part2];
noise_level = 0.3;
z_hat_noisy = z_true + noise_level * randn(N, 1);

% --- 2. 调用 TGV 求解器 ---
% TGV参数需要仔细调整
alpha0 = 50.0;  % 控制断点稀疏性
alpha1 = 10.0;  % 控制平滑区域的保真度
tic;
z_tgv = admm_tgv_filter(z_hat_noisy, alpha0, alpha1, 'max_iter', 500);
toc;

% --- 3. (对比) 调用之前的 L1 趋势滤波求解器 ---
gamma_l1 = 50.0; % 调整以获得可比的结果
z_l1 = admm_trend_filter(z_hat_noisy, 2, gamma_l1);

% --- 4. 可视化对比 ---
figure('Name', 'TGV vs. L1 Trend Filtering', 'NumberTitle', 'off');
set(gcf, 'color', 'w');
subplot(2,1,1);
plot(z_hat_noisy, '.', 'Color', [0.7 0.7 0.9]); hold on;
plot(z_true, 'k-', 'LineWidth', 2.5);
plot(z_l1, 'r-', 'LineWidth', 2);
title(sprintf('L1 Trend Filtering (n=2, \\gamma=%.1f)', gamma_l1));
legend('Noisy', 'True', 'L1 Filtered');
grid on;

subplot(2,1,2);
plot(z_hat_noisy, '.', 'Color', [0.7 0.7 0.9]); hold on;
plot(z_true, 'k-', 'LineWidth', 2.5);
plot(z_tgv, 'b-', 'LineWidth', 2);
title(sprintf('TGV Filter (\\alpha_0=%.1f, \\alpha_1=%.1f)', alpha0, alpha1));
legend('Noisy', 'True', 'TGV Filtered');
grid on;


function z = admm_tgv_filter(z_hat, alpha0, alpha1, varargin)
% ADMM_TGV_FILTER - 使用ADMM算法求解二阶TGV趋势滤波问题
%
% 解决以下优化问题:
%   minimize (1/2)||z - z_hat||_2^2 + TGV_2(z)
%   TGV_2(z) = min_w (alpha1 * ||D1*z - w||_1 + alpha0 * ||D1*w||_1)
%
% 用法:
%   z = admm_tgv_filter(z_hat, alpha0, alpha1)
%   z = admm_tgv_filter(z_hat, alpha0, alpha1, 'rho', rho_val, ...)
%
% 输入:
%   z_hat    - (N x 1) 观测到的含噪声信号向量
%   alpha0   - (标量, >0) 控制二阶稀疏性的正则化参数 (控制w的分段常数性)
%   alpha1   - (标量, >0) 控制一阶稀疏性的正则化参数 (控制z-w的偏差)
%
% 可选输入 (键值对):
%   'rho'      - (标量, >0) ADMM参数 (默认: 1.0)
%   'max_iter' - (整数) 最大迭代次数 (默认: 300)
%   'tol'      - (标量) 收敛容忍度 (默认: 1e-4)
%
% 输出:
%   z        - (N x 1) TGV滤波后的信号向量
%
% 作者: Felix Heide (基于理论模型构建)

% --- 1. 解析输入参数 ---
p = inputParser;
addRequired(p, 'z_hat', @isnumeric);
addRequired(p, 'alpha0', @(x) isscalar(x) && x > 0);
addRequired(p, 'alpha1', @(x) isscalar(x) && x > 0);
addParameter(p, 'rho', 1.0, @(x) isscalar(x) && x > 0);
addParameter(p, 'max_iter', 300, @(x) isscalar(x) && x > 0);
addParameter(p, 'tol', 1e-4, @(x) isscalar(x) && x > 0);
parse(p, z_hat, alpha0, alpha1, varargin{:});

rho = p.Results.rho; % 为简化，这里使用单个rho
max_iter = p.Results.max_iter;
tol_abs = p.Results.tol;

% --- 2. 初始化和预计算 ---
N = length(z_hat);
z_hat = z_hat(:);

% 构建一阶差分矩阵 D1
D1 = diff(eye(N), 1);
D1 = sparse(D1);

% 初始化 ADMM 变量
z = z_hat;
w = zeros(N - 1, 1);
u1 = zeros(N - 1, 1);
u2 = zeros(N - 2, 1);
y1 = zeros(N - 1, 1);
y2 = zeros(N - 2, 1);

% **关键性能优化**: 预计算和分解 (z,w)-update 的左侧块矩阵
D1_w = diff(eye(N-1), 1); % w的一阶差分矩阵
D1_w = sparse(D1_w);

A11 = speye(N) + rho * (D1' * D1);
A12 = -rho * D1';
A21 = -rho * D1;
A22 = rho * speye(N-1) + rho * (D1_w' * D1_w);

LHS = [A11, A12; A21, A22];
R = chol(LHS);
R_t = R';

fprintf('开始 ADMM TGV滤波 (alpha0=%.2f, alpha1=%.2f, rho=%.2f)...\n', alpha0, alpha1, rho);

% --- 3. ADMM 主循环 ---
for k = 1:max_iter
    
    % 存储旧值以检查收敛
    z_old = z;
    
    % a. (z, w)-update: 求解一个块稀疏线性系统
    RHS_z = z_hat + rho * D1' * (u1 - y1);
    RHS_w = rho * (u1 - y1) + rho * D1_w' * (u2 - y2);
    RHS = [RHS_z; RHS_w];
    
    zw = R \ (R_t \ RHS);
    z = zw(1:N);
    w = zw(N+1:end);
    
    % b. u1-update: 软阈值
    D1z_minus_w = D1 * z - w;
    u1 = soft_threshold(D1z_minus_w + y1, alpha1 / rho);
    
    % c. u2-update: 软阈值
    D1w = D1_w * w;
    u2 = soft_threshold(D1w + y2, alpha0 / rho);
    
    % d. 对偶变量更新
    y1 = y1 + (D1z_minus_w - u1);
    y2 = y2 + (D1w - u2);
    
    % e. 检查收敛
    change = norm(z - z_old) / norm(z_old);
    if mod(k, 20) == 0
        fprintf('Iter %d: Relative change = %.4e\n', k, change);
    end
    
    if change < tol_abs
        fprintf('在第 %d 次迭代收敛。\n', k);
        break;
    end
end

if k == max_iter
    fprintf('达到最大迭代次数 %d。\n', max_iter);
end

end

function y = soft_threshold(x, lambda)
    % 软阈值函数
    y = max(0, x - lambda) - max(0, -x - lambda);
end
