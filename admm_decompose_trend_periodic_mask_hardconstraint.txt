% --- 测试脚本: 验证 v4.2 的硬约束均值对齐功能 ---
clear; clc; close all;

% --- 1. 生成测试数据 ---
N = 200;
t = (1:N)';
y = zeros(N,1);
y(1:125) = interp1([1, 20, 40, 60, 80, 100, 125], [2.8, 2.6, 2.5, 2.3, 2.4, 2.5, 2.8], 1:125, 'pchip');
y(126) = 1.0;
y(127:end) = 1.0;
spike_period = 6;
spike_amplitude = 0.5;
spike_indices = 130:spike_period:N;
y(spike_indices) = y(spike_indices) + spike_amplitude * (1 + 0.2*randn(size(spike_indices)))';

% --- 2. 创建掩码 ---
mask = true(N, 1);
mask(spike_indices) = false;
mask(spike_indices - 1) = false;

% --- 3. 设置分解参数 ---
n = 2;
gamma_trend = 5.0;
gamma_noise = 1.0;
rho = 5.0;
gamma_periodic = 0;

% --- 4. 运行分解 ---

% a. 运行 v4.1 (为了对比，需要您保留 v4.1 的代码文件)
% 注意：这里假设您已将之前的 v4.1 代码保存为 admm_decompose_trend_periodic_v4_1.m
fprintf('\n--- 运行 v4.1 (无硬约束) ---\n');
tic;
[xt_v41, ~, ~] = admm_decompose_trend_periodic_v4_1(y, mask, n, gamma_trend, ...
    'gamma_noise', gamma_noise, 'rho', rho, 'gamma_periodic', gamma_periodic);
toc;

% b. 运行 v4.2 (带硬约束)
fprintf('\n--- 运行 v4.2 (带硬约束) ---\n');
tic;
[xt_v42, ~, ~] = admm_decompose_trend_periodic_v4_2(y, mask, n, gamma_trend, ...
    'gamma_noise', gamma_noise, 'rho', rho, 'gamma_periodic', gamma_periodic);
toc;

% --- 5. 可视化对比 ---
figure('Name', 'v4.2 Hard Constraint 验证', 'NumberTitle', 'off', 'Position', [100, 100, 1000, 500]);
set(gcf, 'color', 'w');

plot(t, y, 'o', 'Color', [0.7 0.7 1], 'DisplayName', '观测信号 y (好点)');
hold on;
plot(t(~mask), y(~mask), 'kx', 'MarkerSize', 8, 'LineWidth', 1.5, 'DisplayName', '被忽略的点 (Masked)');

plot(t, xt_v41, 'm--', 'LineWidth', 2, 'DisplayName', 'v4.1 结果 (有偏移)');
plot(t, xt_v42, 'r-', 'LineWidth', 2, 'DisplayName', 'v4.2 结果 (无偏移)');

legend('show', 'Location', 'best');
title('硬约束对齐 vs. 无约束');
grid on;
xlabel('样本索引');
ylabel('幅值');
xlim([95, 195]);

% 计算并显示均值差异
mean_y_masked = mean(y(mask));
mean_xt_v41 = mean(xt_v41(mask));
mean_xt_v42 = mean(xt_v42(mask));
fprintf('\n观测数据均值 (好点): %.4f\n', mean_y_masked);
fprintf('v4.1 结果均值 (好点): %.4f (偏移: %.4f)\n', mean_xt_v41, mean_xt_v41 - mean_y_masked);
fprintf('v4.2 结果均值 (好点): %.4f (偏移: %.4f)\n', mean_xt_v42, mean_xt_v42 - mean_y_masked);

function [x_trend, x_periodic, x_noise] = admm_decompose_trend_periodic_v4_2(y, mask, n, gamma_trend, varargin)
% ADMM_DECOMPOSE_TREND_PERIODIC - (v4.2 - Hard Constraint for DC Offset)
%
% 增加了硬约束来严格消除直流偏置问题。
%
% 解决以下优化问题:
%   minimize   phi_trend(x_t) + phi_periodic(x_p) + phi_noise(x_n)
%   subject to M(x_t + x_p + x_n) = M(y)
%              1'*M*x_t = 1'*M*y
%
% 用法:
%   [xt, xp, xn] = admm_decompose_trend_periodic_v4_2(y, mask, n, gamma_trend, ...)
%
% 输入:
%   y             - (N x 1) 观测信号
%   mask          - (N x 1) 布尔或0/1掩码, true/1表示“好点”
%   n             - (标量) 趋势成分的阶数
%   gamma_trend   - (标量, >=0) 趋势成分的正则化参数
%
% 可选输入 (键值对):
%   'gamma_noise'    - (标量, >0) 噪声成分的权重。(默认: 1.0)
%   'gamma_periodic' - (标量, >=0) 周期成分的权重。(默认: 1.0)
%   'rho'            - (标量, >0) ADMM参数 (默认: 10.0)
%   'max_iter'       - (整数) 最大迭代次数 (默认: 200)
%   'tol_abs'        - (标量) 绝对收敛容忍度 (默认: 1e-4)
%   'tol_rel'        - (标量) 相对收敛容忍度 (默认: 1e-2)
%   'verbose'        - (逻辑) 是否打印迭代信息 (默认: true)
%   'use_gmetv'      - (逻辑) (接口保留) 是否使用 GME-TV (默认: false)
%   'gme_K'          - (整数) (接口保留) GME-TV 参数 K (默认: 10)
%
% 作者: Felix Heide (基于理论模型构建 v4.2)

% --- 1. 解析输入参数 ---
p = inputParser;
addRequired(p, 'y', @isnumeric);
addRequired(p, 'mask', @(x) isnumeric(x) || islogical(x));
addRequired(p, 'n', @(x) isscalar(x) && x >= 0);
addRequired(p, 'gamma_trend', @(x) isscalar(x) && x >= 0);
addParameter(p, 'gamma_noise', 1.0, @(x) isscalar(x) && x > 0);
addParameter(p, 'gamma_periodic', 1.0, @(x) isscalar(x) && x >= 0);
addParameter(p, 'rho', 10.0, @(x) isscalar(x) && x > 0);
addParameter(p, 'max_iter', 200, @(x) isscalar(x) && x > 0);
addParameter(p, 'tol_abs', 1e-4, @isnumeric);
addParameter(p, 'tol_rel', 1e-2, @isnumeric);
addParameter(p, 'verbose', true, @islogical);
addParameter(p, 'use_gmetv', false, @islogical);
addParameter(p, 'gme_K', 10, @(x) isscalar(x) && x > 0);
parse(p, y, mask, n, gamma_trend, varargin{:});

gamma_noise = p.Results.gamma_noise;
gamma_periodic = p.Results.gamma_periodic;
rho = p.Results.rho;
max_iter = p.Results.max_iter;
tol_abs = p.Results.tol_abs;
tol_rel = p.Results.tol_rel;
verbose = p.Results.verbose;
use_gmetv = p.Results.use_gmetv;
gme_K = p.Results.gme_K;

% --- 2. 初始化和预计算 ---
N = length(y);
y = y(:);
mask = logical(mask(:));
num_good_points = sum(mask);

% 预计算均值约束的目标值
mean_y_masked = sum(y(mask)) / num_good_points;

if gamma_periodic > 0
    Ap = spdiags([ones(N-1,1), ones(N-1,1)], [0, 1], N-1, N);
    L_Ap = chol(Ap * Ap', 'lower'); L_Ap_t = L_Ap';
else
    Ap = []; L_Ap = []; L_Ap_t = [];
end

% ADMM 变量 (使用 z/u 形式以简化投影步骤)
x_trend = y; x_periodic = zeros(N, 1); x_noise = zeros(N, 1);
z_trend = x_trend; z_periodic = x_periodic; z_noise = x_noise;
u_trend = zeros(N, 1); u_periodic = zeros(N, 1); u_noise = zeros(N, 1);

if verbose
    fprintf('开始 ADMM 信号分解 (v4.2 - Hard DC Constraint)...\n');
end

% --- 3. ADMM 主循环 ---
for k = 1:max_iter
    
    z_trend_old = z_trend;
    
    % a. x-updates (独立的近端算子)
    x_trend    = prox_update_trend_masked(z_trend - u_trend, mask, n, gamma_trend, rho);
    x_periodic = prox_update_periodic(z_periodic - u_periodic, gamma_periodic, Ap, L_Ap, L_Ap_t);
    x_noise    = prox_update_noise(z_noise - u_noise, gamma_noise, rho);
    
    % b. z-updates (联合投影)
    xt_tilde = x_trend + u_trend;
    xp_tilde = x_periodic + u_periodic;
    xn_tilde = x_noise + u_noise;
    
    % 投影到满足两个线性约束的超平面
    % 约束1: M(zt+zp+zn) = M(y)
    % 约束2: 1'*M*zt = 1'*M*y
    
    % 首先满足约束1 (只在好点上)
    s_tilde = xt_tilde + xp_tilde + xn_tilde;
    residual = s_tilde(mask) - y(mask);
    
    % 简单的平均分配残差
    z_trend(mask) = xt_tilde(mask) - residual/3;
    z_periodic(mask) = xp_tilde(mask) - residual/3;
    z_noise(mask) = xn_tilde(mask) - residual/3;
    
    % 坏点处 z = x+u
    z_trend(~mask) = xt_tilde(~mask);
    z_periodic(~mask) = xp_tilde(~mask);
    z_noise(~mask) = xn_tilde(~mask);
    
    % 然后满足约束2 (投影zt到均值约束超平面)
    current_mean_zt = sum(z_trend(mask)) / num_good_points;
    mean_diff = current_mean_zt - mean_y_masked;
    
    % 将差值均匀地从好点上减去
    z_trend(mask) = z_trend(mask) - mean_diff;
    
    % 为了保持总和不变，将差值加到其他分量上 (只在好点)
    z_periodic(mask) = z_periodic(mask) + mean_diff / 2;
    z_noise(mask) = z_noise(mask) + mean_diff / 2;
    
    % c. u-updates (对偶变量更新)
    u_trend    = u_trend    + (x_trend - z_trend);
    u_periodic = u_periodic + (x_periodic - z_periodic);
    u_noise    = u_noise    + (x_noise - z_noise);
    
    % d. 检查收敛条件
    r_prim1 = norm(z_trend(mask) + z_periodic(mask) + z_noise(mask) - y(mask));
    r_prim2 = abs(sum(z_trend(mask))/num_good_points - mean_y_masked);
    r_dual = rho * norm(z_trend - z_trend_old);
    
    if verbose && mod(k, 10) == 0
        fprintf('Iter %d: Primal Res (sum) = %.4f, Primal Res (mean) = %.4f, Dual Res = %.4f\n', ...
            k, r_prim1, r_prim2, r_dual);
    end
    
    if r_prim1 < tol_abs && r_prim2 < tol_abs && r_dual < tol_abs
        if verbose, fprintf('在第 %d 次迭代收敛。\n', k); end
        break;
    end
end

if k == max_iter && verbose, fprintf('达到最大迭代次数 %d。\n', max_iter); end

% --- 4. 分配最终结果 ---
x_trend = z_trend;
x_periodic = z_periodic;
x_noise = z_noise;

end

% --- Helper Functions ---

function z_t = prox_update_trend_masked(v, mask, n, gamma_t, rho)
    if gamma_t > 0
        z_t = admm_trend_filter_masked(v, n, gamma_t/rho, mask, 'rho', 1.0, 'max_iter', 20);
    else
        z_t = v;
    end
end

function z_p = prox_update_periodic(v, gamma_p, Ap, L_Ap, L_Ap_t)
    if gamma_p > 0
        temp = L_Ap_t \ (L_Ap \ (Ap * v));
        z_p = v - Ap' * temp;
        z_p = z_p - mean(z_p);
    else
        z_p = zeros(size(v));
    end
end

function z_n = prox_update_noise(v, gamma_n, rho)
    z_n = (rho / (gamma_n + rho)) * v;
    z_n = z_n - mean(z_n);
end

% --- Sub-function: Masked Trend Filter ---
function z = admm_trend_filter_masked(z_hat, n, gamma, mask, varargin)
    p = inputParser;
    addRequired(p, 'z_hat', @isnumeric);
    addRequired(p, 'n', @(x) isscalar(x) && x >= 0);
    addRequired(p, 'gamma', @(x) isscalar(x) && x > 0);
    addRequired(p, 'mask', @(x) isnumeric(x) || islogical(x));
    addParameter(p, 'rho', 1.0, @(x) isscalar(x) && x > 0);
    addParameter(p, 'max_iter', 50, @(x) isscalar(x) && x > 0);
    addParameter(p, 'tol', 1e-4, @(x) isscalar(x) && x > 0);
    parse(p, z_hat, n, gamma, mask, varargin{:});

    rho = p.Results.rho;
    max_iter = p.Results.max_iter;
    tol_abs = p.Results.tol;

    N = length(z_hat);
    z_hat = z_hat(:);
    mask = logical(mask(:));

    D = diff(speye(N), n);
    D = sparse(D);

    z = z_hat;
    u = zeros(N - n, 1);
    y = zeros(N - n, 1);

    M_mask = spdiags(double(mask), 0, N, N);
    LHS = M_mask + rho * (D' * D);
    
    try
        R = chol(LHS);
        R_t = R';
        use_chol = true;
    catch
        % 如果矩阵不是正定的 (可能因为mask全为0)，则退回到通用求解器
        use_chol = false;
    end

    for k = 1:max_iter
        u_old = u;
        RHS = M_mask * z_hat + rho * D' * (u - y);
        if use_chol
            z = R \ (R_t \ RHS);
        else
            z = LHS \ RHS;
        end
        
        Dz_plus_y = D * z + y;
        threshold = gamma / rho;
        u = max(0, Dz_plus_y - threshold) - max(0, -Dz_plus_y - threshold);
        y = y + (D * z - u);
        
        if norm(u - u_old) < tol_abs
            break;
        end
    end
end
