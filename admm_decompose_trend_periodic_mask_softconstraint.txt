function [x_trend, x_periodic, x_noise] = admm_decompose_trend_periodic_v4_3(y, mask, n, gamma_trend, varargin)
% ADMM_DECOMPOSE_TREND_PERIODIC - (v4.3 - Soft Constraint for DC Offset)
%
% 使用软约束（二次惩罚项）来引导趋势项的均值，以获得更鲁棒的结果。
%
% 解决以下优化问题:
%   minimize   phi_trend(x_t) + phi_periodic(x_p) + phi_noise(x_n) + phi_mean(x_t)
%   subject to M(x_t + x_p + x_n) = M(y)
%
% 用法:
%   [xt, xp, xn] = admm_decompose_trend_periodic_v4_3(y, mask, n, gamma_trend, 'gamma_mean', gm, ...)
%
% 输入:
%   y             - (N x 1) 观测信号
%   mask          - (N x 1) 布尔或0/1掩码, true/1表示“好点”
%   n             - (标量) 趋势成分的阶数
%   gamma_trend   - (标量, >=0) 趋势成分的正则化参数
%
% 可选输入 (键值对):
%   'gamma_noise'    - (标量, >0) 噪声成分的权重。(默认: 1.0)
%                       参考值: 1.0。值越大，表示对观测数据越信任，噪声越小。
%   'gamma_periodic' - (标量, >=0) 周期成分的权重。(默认: 1.0)
%                       参考值: >0 启用，0 禁用。
%   'gamma_mean'     - (标量, >=0) 均值软约束的权重。(默认: 100.0)
%                       参考值: 10-1000。值越大，约束越强，越接近硬约束。0表示无约束。
%   'rho'            - (标量, >0) ADMM参数。(默认: 10.0)
%                       参考值: 通常与主要的gamma参数在同一数量级。
%   'max_iter'       - (整数) 最大迭代次数。(默认: 200)
%   'tol_abs'        - (标量) 绝对收敛容忍度。(默认: 1e-4)
%   'tol_rel'        - (标量) 相对收敛容忍度。(默认: 1e-2)
%   'verbose'        - (逻辑) 是否打印迭代信息。(默认: true)
%   'use_gmetv'      - (逻辑) (接口保留) 是否使用 GME-TV。(默认: false)
%   'gme_K'          - (整数) (接口保留) GME-TV 参数 K。(默认: 10)

% --- 1. 解析输入参数 ---
p = inputParser;
addRequired(p, 'y', @isnumeric);
addRequired(p, 'mask', @(x) isnumeric(x) || islogical(x));
addRequired(p, 'n', @(x) isscalar(x) && x >= 0);
addRequired(p, 'gamma_trend', @(x) isscalar(x) && x >= 0);
addParameter(p, 'gamma_noise', 1.0, @(x) isscalar(x) && x > 0);
addParameter(p, 'gamma_periodic', 1.0, @(x) isscalar(x) && x >= 0);
addParameter(p, 'gamma_mean', 100.0, @(x) isscalar(x) && x >= 0);
addParameter(p, 'rho', 10.0, @(x) isscalar(x) && x > 0);
addParameter(p, 'max_iter', 200, @(x) isscalar(x) && x > 0);
addParameter(p, 'tol_abs', 1e-4, @isnumeric);
addParameter(p, 'tol_rel', 1e-2, @isnumeric);
addParameter(p, 'verbose', true, @islogical);
addParameter(p, 'use_gmetv', false, @islogical);
addParameter(p, 'gme_K', 10, @(x) isscalar(x) && x > 0);
parse(p, y, mask, n, gamma_trend, varargin{:});

gamma_noise = p.Results.gamma_noise;
gamma_periodic = p.Results.gamma_periodic;
gamma_mean = p.Results.gamma_mean;
rho = p.Results.rho;
max_iter = p.Results.max_iter;
tol_abs = p.Results.tol_abs;
tol_rel = p.Results.tol_rel;
verbose = p.Results.verbose;
use_gmetv = p.Results.use_gmetv;
gme_K = p.Results.gme_K;

% --- 2. 初始化和预计算 ---
N = length(y);
y = y(:);
mask = logical(mask(:));
num_good_points = sum(mask);
mean_y_masked = sum(y(mask)) / num_good_points;

if gamma_periodic > 0
    Ap = spdiags([ones(N-1,1), ones(N-1,1)], [0, 1], N-1, N);
    L_Ap = chol(Ap * Ap', 'lower'); L_Ap_t = L_Ap';
else
    Ap = []; L_Ap = []; L_Ap_t = [];
end

x_trend = y;
x_periodic = zeros(N, 1);
x_noise = zeros(N, 1);
u = zeros(N, 1);

if verbose
    fprintf('开始 ADMM 信号分解 (v4.3 - Soft DC Constraint)...\n');
end

% --- 3. ADMM 主循环 (使用 v3.0 的正确更新逻辑) ---
for k = 1:max_iter
    x_trend_old = x_trend;
    
    % a. x_trend 更新 (包含均值软约束)
    v_trend = y - x_periodic - x_noise - u;
    if use_gmetv
        % ** GME-TV 接口保留处 **
        warning('GME-TV with masking is not yet implemented. Falling back to L1-TV.');
        x_trend = prox_update_trend_masked_soft_mean(v_trend, mask, n, gamma_trend, rho, gamma_mean, mean_y_masked);
    else
        x_trend = prox_update_trend_masked_soft_mean(v_trend, mask, n, gamma_trend, rho, gamma_mean, mean_y_masked);
    end
    
    % b. x_periodic 更新
    v_periodic = y - x_trend - x_noise - u;
    x_periodic = prox_update_periodic(v_periodic, gamma_periodic, Ap, L_Ap, L_Ap_t);
    
    % c. x_noise 更新
    v_noise = y - x_trend - x_periodic - u;
    x_noise = prox_update_noise_masked(v_noise, mask, gamma_noise, rho);
    
    % d. 对偶变量 u 更新
    residual = x_trend + x_periodic + x_noise - y;
    u(mask) = u(mask) + residual(mask);
    
    % e. 检查收敛条件
    r_prim = norm(residual(mask));
    r_dual = rho * norm(x_trend - x_trend_old);
    eps_prim = sqrt(num_good_points)*tol_abs + tol_rel*max([norm(x_trend(mask)), norm(x_periodic(mask)), norm(x_noise(mask)), norm(y(mask))]);
    eps_dual = sqrt(N)*tol_abs + tol_rel*norm(rho*u);
    
    if verbose && mod(k, 10) == 0
        fprintf('Iter %d: Primal Res = %.4f (eps=%.4f), Dual Res = %.4f (eps=%.4f)\n', ...
            k, r_prim, eps_prim, r_dual, eps_dual);
    end
    
    if r_prim < eps_prim && r_dual < eps_dual
        if verbose, fprintf('在第 %d 次迭代收敛。\n', k); end
        break;
    end
end

if k == max_iter && verbose, fprintf('达到最大迭代次数 %d。\n', max_iter); end

end

% --- Helper Functions ---

function z_t = prox_update_trend_masked_soft_mean(v, mask, n, gamma_t, rho, gamma_m, mean_y)
    % 趋势项的近端更新，包含均值软约束
    % 求解: min gamma_t*||Dnx||_1 + (rho/2)||M(x-v)||_2^2 + (gamma_m/2)(mean(Mx)-mean(My))^2
    % 这是一个 l1 正则化的、带加权二次项的优化问题。
    % 我们可以通过修改 admm_trend_filter_masked 来精确求解。
    
    if gamma_t > 0
        % 为了简洁，这里采用一个迭代修正的近似方法，性能也很好：
        % 1. 先求解不带均值约束的近端算子
        xt_uncons = admm_trend_filter_masked(v, n, gamma_t/rho, mask, 'rho', 1.0, 'max_iter', 20);
        
        % 2. 然后求解一个简单的二次问题来修正均值
        if gamma_m > 0
            num_good_points = sum(mask);
            mean_xt_uncons = sum(xt_uncons(mask)) / num_good_points;
            
            % 求解 min (gamma_m/2)(m-mean_y)^2 + (rho/2)*Nm*(m-mean_xt_uncons)^2
            % m 是要找的最优均值
            optimal_mean = (gamma_m * mean_y + rho * num_good_points * mean_xt_uncons) / (gamma_m + rho * num_good_points);
            
            % 将修正应用到好点上
            mean_diff = optimal_mean - mean_xt_uncons;
            z_t = xt_uncons;
            z_t(mask) = z_t(mask) + mean_diff;
        else
            z_t = xt_uncons;
        end
    else
        z_t = v;
    end
end

function z_p = prox_update_periodic(v, gamma_p, Ap, L_Ap, L_Ap_t)
    if gamma_p > 0
        temp = L_Ap_t \ (L_Ap \ (Ap * v));
        z_p = v - Ap' * temp;
        z_p = z_p - mean(z_p);
    else
        z_p = zeros(size(v));
    end
end

function z_n = prox_update_noise_masked(v, mask, gamma_n, rho)
    z_n = zeros(size(v));
    z_n(mask) = (rho / (gamma_n + rho)) * v(mask);
    z_n(~mask) = v(~mask);
    z_n = z_n - mean(z_n);
end

% --- Sub-function: Masked Trend Filter (与v4.1相同) ---
function z = admm_trend_filter_masked(z_hat, n, gamma, mask, varargin)
    p = inputParser;
    addRequired(p, 'z_hat', @isnumeric);
    addRequired(p, 'n', @(x) isscalar(x) && x >= 0);
    addRequired(p, 'gamma', @(x) isscalar(x) && x > 0);
    addRequired(p, 'mask', @(x) isnumeric(x) || islogical(x));
    addParameter(p, 'rho', 1.0, @(x) isscalar(x) && x > 0);
    addParameter(p, 'max_iter', 50, @(x) isscalar(x) && x > 0);
    addParameter(p, 'tol', 1e-4, @(x) isscalar(x) && x > 0);
    parse(p, z_hat, n, gamma, mask, varargin{:});

    rho = p.Results.rho;
    max_iter = p.Results.max_iter;
    tol_abs = p.Results.tol;

    N = length(z_hat);
    z_hat = z_hat(:);
    mask = logical(mask(:));

    D = diff(speye(N), n);
    D = sparse(D);

    z = z_hat;
    u = zeros(N - n, 1);
    y = zeros(N - n, 1);

    M_mask = spdiags(double(mask), 0, N, N);
    LHS = M_mask + rho * (D' * D);
    
    try
        R = chol(LHS);
        R_t = R';
        use_chol = true;
    catch
        use_chol = false;
    end

    for k = 1:max_iter
        u_old = u;
        RHS = M_mask * z_hat + rho * D' * (u - y);
        if use_chol
            z = R \ (R_t \ RHS);
        else
            z = LHS \ RHS;
        end
        
        Dz_plus_y = D * z + y;
        threshold = gamma / rho;
        u = max(0, Dz_plus_y - threshold) - max(0, -Dz_plus_y - threshold);
        y = y + (D * z - u);
        
        if norm(u - u_old) < tol_abs
            break;
        end
    end
end
