% --- Main Test Script for ADMM Signal Decomposition (v2.0) ---
clear; clc; close all;

% --- 1. 生成测试数据 ---
[y_ideal, y_residual, true_signals] = generate_test_data();

% --- 2. Case 1: 理想分解验证 ---
fprintf('--- Case 1: 理想分解验证 ---\n');
n = 1; % 趋势是分段常数
gamma_trend_ideal = 10.0;
gamma_noise_ideal = 1.0;
rho_ideal = 10.0;

tic;
[xt1, xp1, xn1] = admm_decompose_trend_periodic(y_ideal, n, gamma_trend_ideal, ...
    'gamma_noise', gamma_noise_ideal, 'rho', rho_ideal);
toc;

% 可视化 Case 1
plot_decomposition_results('理想分解', y_ideal, {xt1, xp1, xn1}, true_signals);


% --- 3. Case 2: 残留振荡信号分解 ---
fprintf('\n--- Case 2: 残留振荡信号分解 ---\n');
n_res = 2; % 趋势是平滑曲线，用二阶
gamma_trend_res = 80.0;
gamma_noise_res = 1.0;
rho_res = 20.0;

tic;
[xt2, xp2, xn2] = admm_decompose_trend_periodic(y_residual.y, n_res, gamma_trend_res, ...
    'gamma_noise', gamma_noise_res, 'rho', rho_res);
toc;

% 可视化 Case 2
plot_decomposition_results('残留振荡分解', y_residual.y, {xt2, xp2, xn2}, y_residual.true_signals);


% --- 4. Case 3: 验证退化能力 (gamma_periodic = 0) ---
fprintf('\n--- Case 3: 验证退化能力 (gamma_periodic = 0) ---\n');
tic;
[xt3, xp3, xn3] = admm_decompose_trend_periodic(y_residual.y, n_res, gamma_trend_res, ...
    'gamma_periodic', 0, 'gamma_noise', gamma_noise_res, 'rho', rho_res);
toc;

% 此时 xp3 应该为0, xt3 + xn3 = y
figure('Name', '退化能力验证', 'NumberTitle', 'off');
plot(y_residual.y, 'b-', 'DisplayName', 'Original y'); hold on;
plot(xt3, 'r--', 'LineWidth', 2, 'DisplayName', 'Trend (gamma_p=0)');
plot(xt3 + xn3, 'g:', 'LineWidth', 2, 'DisplayName', 'Trend + Noise');
legend; title('当 gamma_{periodic}=0 时, 周期项为0');
grid on;
fprintf('恢复的周期项 L2 范数: %.4f (应接近0)\n', norm(xp3));


% --- Helper function for data generation ---
function [y_ideal, y_residual, true_signals] = generate_test_data()
    N = 200;
    t = (1:N)';
    
    % Case 1: 理想情况
    true_signals.trend = [28*ones(40,1); 31*ones(50,1); 28*ones(30,1); 34*ones(80,1)];
    true_signals.periodic = 3.0 * (-1).^(t);
    true_signals.noise = 0.2 * randn(N, 1);
    true_signals.noise = true_signals.noise - mean(true_signals.noise); % 确保零均值
    y_ideal = true_signals.trend + true_signals.periodic + true_signals.noise;
    
    % Case 2: 残留振荡情况
    y_residual.true_signals.trend = interp1([1, 50, 100, 150, 200], [0.8, 1.5, 1.1, 1.4, 1.0], t, 'pchip');
    y_residual.true_signals.periodic = 0.15 * (-1).^(t);
    y_residual.true_signals.noise = 0.05 * randn(N, 1);
    y_residual.true_signals.noise = y_residual.true_signals.noise - mean(y_residual.true_signals.noise);
    y_residual.y = y_residual.true_signals.trend + y_residual.true_signals.periodic + y_residual.true_signals.noise;
end

% --- Helper function for plotting ---
function plot_decomposition_results(fig_name, y, recovered, true_signals)
    figure('Name', fig_name, 'NumberTitle', 'off', 'Position', [100, 100, 800, 700]);
    set(gcf, 'color', 'w');
    
    xt = recovered{1}; xp = recovered{2}; xn = recovered{3};
    
    subplot(4,1,1);
    plot(y, 'b-', 'DisplayName', 'Observed y');
    hold on;
    plot(xt, 'r-', 'LineWidth', 2, 'DisplayName', 'Recovered Trend');
    plot(true_signals.trend, 'k--', 'LineWidth', 1.5, 'DisplayName', 'True Trend');
    legend('show'); title('Observation vs. Recovered Trend'); grid on;

    subplot(4,1,2);
    plot(xp, 'g-', 'DisplayName', 'Recovered Periodic');
    hold on;
    plot(true_signals.periodic, 'k--', 'DisplayName', 'True Periodic');
    legend('show'); title('Recovered Periodic Component'); grid on;

    subplot(4,1,3);
    plot(xn, 'm.', 'DisplayName', 'Recovered Noise');
    hold on;
    plot(true_signals.noise, 'k.', 'MarkerSize', 2, 'DisplayName', 'True Noise');
    legend('show'); title('Recovered Noise Component'); grid on;
    
    subplot(4,1,4);
    residual = y - (xt + xp + xn);
    plot(residual, 'c-');
    title(sprintf('Final Reconstruction Error (L2 Norm: %.4f)', norm(residual)));
    grid on;
end


function [x_trend, x_periodic, x_noise] = admm_decompose_trend_periodic(y, n, gamma_trend, varargin)
% ADMM_DECOMPOSE_TREND_PERIODIC - (v2.0) 将信号分解为趋势、周期-2干扰和噪声
%
% 解决以下优化问题:
%   minimize   phi_trend(x_t) + phi_periodic(x_p) + phi_noise(x_n)
%   subject to x_t + x_p + x_n = y
%
% 其中:
%   phi_trend(x)   = gamma_trend * ||D_n x||_1
%   phi_periodic(x) = gamma_periodic * I(A_p x = 0, 1'*x = 0) (gamma_p -> inf)
%   phi_noise(x)   = (gamma_noise/2)||x||_2^2 + I(1'*x = 0)
%
% 用法:
%   [xt, xp, xn] = admm_decompose_trend_periodic(y, n, gamma_trend, 'gamma_periodic', gp, 'gamma_noise', gn)
%
% 输入:
%   y             - (N x 1) 观测信号
%   n             - (标量) 趋势成分的阶数
%   gamma_trend   - (标量, >=0) 趋势成分的正则化参数
%
% 可选输入 (键值对):
%   'gamma_periodic' - (标量, >=0) 周期成分的权重。设为 > 0 启用分解。(默认: 1.0)
%   'gamma_noise'    - (标量, >0) 噪声成分的权重。(默认: 1.0)
%   'rho'            - (标量, >0) ADMM参数 (默认: 10.0)
%   'max_iter'       - (整数) 最大迭代次数 (默认: 150)
%   'tol'            - (标量) 收敛容忍度 (默认: 1e-5)
%   'verbose'        - (逻辑) 是否打印迭代信息 (默认: true)
%
% 输出:
%   x_trend       - (N x 1) 恢复的趋势成分
%   x_periodic    - (N x 1) 恢复的周期-2干扰成分
%   x_noise       - (N x 1) 恢复的噪声成分
%
% 作者: Felix Heide (基于理论模型构建 v2.0)

% --- 1. 解析输入参数 ---
p = inputParser;
addRequired(p, 'y', @isnumeric);
addRequired(p, 'n', @(x) isscalar(x) && x >= 0);
addRequired(p, 'gamma_trend', @(x) isscalar(x) && x >= 0);
addParameter(p, 'gamma_periodic', 1.0, @(x) isscalar(x) && x >= 0);
addParameter(p, 'gamma_noise', 1.0, @(x) isscalar(x) && x > 0);
addParameter(p, 'rho', 10.0, @(x) isscalar(x) && x > 0);
addParameter(p, 'max_iter', 150, @(x) isscalar(x) && x > 0);
addParameter(p, 'tol', 1e-5, @(x) isscalar(x) && x > 0);
addParameter(p, 'verbose', true, @islogical);
parse(p, y, n, gamma_trend, varargin{:});

gamma_periodic = p.Results.gamma_periodic;
gamma_noise = p.Results.gamma_noise;
rho = p.Results.rho;
max_iter = p.Results.max_iter;
tol_abs = p.Results.tol;
verbose = p.Results.verbose;

% --- 2. 初始化和预计算 ---
N = length(y);
y = y(:);

% a. 周期成分预计算
if gamma_periodic > 0
    Ap = spdiags([ones(N-1,1), ones(N-1,1)], [0, 1], N-1, N);
    L_Ap = chol(Ap * Ap', 'lower');
    L_Ap_t = L_Ap';
else
    Ap = []; L_Ap = []; L_Ap_t = []; % 如果不使用周期项，则不计算
end

% b. 初始化 ADMM 变量
z_trend = y;
z_periodic = zeros(N, 1);
z_noise = zeros(N, 1);

u_trend = zeros(N, 1);
u_periodic = zeros(N, 1);
u_noise = zeros(N, 1);

if verbose, fprintf('开始 ADMM 信号分解 (v2.0)...\n'); end

% --- 3. ADMM 主循环 ---
for k = 1:max_iter
    
    z_trend_old = z_trend;
    
    % a. 计算平均值 (共识步骤)
    z_avg = (z_trend + z_periodic + z_noise) / 3;
    u_avg = (u_trend + u_periodic + u_noise) / 3;
    
    % b. 各成分的近端算子更新 (Proximal Updates)
    
    % i. 趋势成分更新
    v_trend = z_avg - u_avg + (y - z_avg)/3;
    z_trend = prox_update_trend(v_trend, n, gamma_trend, rho);
    
    % ii. 周期成分更新
    v_periodic = z_avg - u_avg + (y - z_avg)/3;
    z_periodic = prox_update_periodic(v_periodic, gamma_periodic, Ap, L_Ap, L_Ap_t);
    
    % iii. 噪声成分更新
    v_noise = z_avg - u_avg + (y - z_avg)/3;
    z_noise = prox_update_noise(v_noise, gamma_noise, rho);
    
    % c. 对偶变量更新
    u_trend    = u_trend    + (z_trend    - (z_avg + (y - z_avg)/3));
    u_periodic = u_periodic + (z_periodic - (z_avg + (y - z_avg)/3));
    u_noise    = u_noise    + (z_noise    - (z_avg + (y - z_avg)/3));
    
    % d. 检查收敛条件
    change = norm(z_trend - z_trend_old) / (norm(z_trend_old) + 1e-9);
    if verbose && mod(k, 10) == 0
        fprintf('Iter %d: Relative Change = %.6f\n', k, change);
    end
    
    if change < tol_abs && k > 1
        if verbose, fprintf('在第 %d 次迭代收敛。\n', k); end
        break;
    end
end

if k == max_iter && verbose
    fprintf('达到最大迭代次数 %d。\n', max_iter);
end

% --- 5. 分配最终结果 ---
x_trend = z_trend;
x_periodic = z_periodic;
x_noise = z_noise;

end

% --- Helper Functions for Proximal Updates (Pin-to-Pin replaceable) ---

function z_t = prox_update_trend(v, n, gamma_t, rho)
    % 趋势项的近端更新: 调用 l1 趋势滤波器
    if gamma_t > 0
        % 注意: 内部求解器的正则化参数是 gamma/rho
        % 为了解耦，内部求解器使用自己的rho，设为1.0即可
        z_t = admm_trend_filter(v, n, gamma_t/rho, 'rho', 1.0, 'max_iter', 15, 'tol', 1e-3);
    else
        z_t = v; % 如果gamma_trend为0，则不进行滤波
    end
end

function z_p = prox_update_periodic(v, gamma_p, Ap, L_Ap, L_Ap_t)
    % 周期项的近端更新: 投影到零均值和周期-2湮灭子空间
    if gamma_p > 0
        % 投影到 Ap*z = 0
        temp = L_Ap_t \ (L_Ap \ (Ap * v));
        z_p = v - Ap' * temp;
        % 投影到零均值
        z_p = z_p - mean(z_p);
    else
        z_p = zeros(size(v)); % 如果不使用周期项，则其贡献为0
    end
end

function z_n = prox_update_noise(v, gamma_n, rho)
    % 噪声项的近端更新: 带权重的缩放并投影到零均值
    z_n = (rho / (gamma_n + rho)) * v;
    % 投影到零均值
    z_n = z_n - mean(z_n);
end
