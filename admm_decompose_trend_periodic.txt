% --- 1. 生成符合描述的合成数据 ---
N = 200;
t = (1:N)';

% a. 真实趋势信号 (分段常数)
x_trend_true = [28*ones(20,1); 31*ones(20,1); 34*ones(20,1); 28*ones(20,1); 30*ones(20,1)];

% b. 周期-2 干扰信号
amplitude = 3; % 对应第一张图的振荡幅度
x_periodic_true = amplitude * (-1).^(t);

% c. 随机噪声
noise_level = 0.2;
x_noise_true = noise_level * randn(N, 1);

% d. 合成观测信号 y
y = x_trend_true + x_periodic_true + x_noise_true;

% 模拟第二张图的情况：趋势信号本身不平滑
y_smooth_trend = interp1(1:50:201, [0.8, 1.1, 1.5, 1.2, 1.4, 1.0], 1:N, 'pchip')';
y_with_residual_oscillation = y_smooth_trend + 0.1 * amplitude * (-1).^(t) + 0.05 * randn(N,1);


% --- 2. 调用分解求解器 ---
n = 1; % 趋势是分段常数，用一阶差分
gamma_trend = 15.0; % 正则化参数

tic;
[xt_recon, xp_recon, xn_recon] = admm_decompose_trend_periodic(y_with_residual_oscillation, n, gamma_trend, 'rho', 20);
toc;

% --- 3. 可视化结果 ---
figure('Name', 'Signal Decomposition Results', 'NumberTitle', 'off', 'Position', [100, 100, 800, 600]);
set(gcf, 'color', 'w');

% 绘制原始信号和恢复的趋势
subplot(3,1,1);
plot(y_with_residual_oscillation, 'b-', 'DisplayName', 'Observed Signal y');
hold on;
plot(xt_recon, 'r-', 'LineWidth', 2, 'DisplayName', 'Recovered Trend x_{trend}');
plot(y_smooth_trend, 'k--', 'LineWidth', 2, 'DisplayName', 'True Smooth Trend');
legend('show');
title('Observation vs. Recovered Trend');
grid on;

% 绘制恢复的周期成分
subplot(3,1,2);
plot(xp_recon, 'g-', 'DisplayName', 'Recovered Periodic x_{periodic}');
hold on;
plot(0.1 * amplitude * (-1).^(t), 'k--', 'DisplayName', 'True Periodic Component');
legend('show');
title('Recovered Periodic Component');
grid on;

% 绘制恢复的噪声成分
subplot(3,1,3);
plot(xn_recon, 'm.', 'DisplayName', 'Recovered Noise x_{noise}');
legend('show');
title('Recovered Noise Component');
grid on;

function [x_trend, x_periodic, x_noise] = admm_decompose_trend_periodic(y, n, gamma_trend, varargin)
% ADMM_DECOMPOSE_TREND_PERIODIC - 将信号分解为趋势、周期-2干扰和噪声
%
% 解决以下优化问题:
%   minimize   gamma_trend * ||D_n x_t||_1 + I(A_p x_p = 0) + (1/2)||x_n||_2^2
%   subject to x_t + x_p + x_n = y
%
% 用法:
%   [xt, xp, xn] = admm_decompose_trend_periodic(y, n, gamma_trend)
%   ... = admm_decompose_trend_periodic(y, n, gamma_trend, 'rho', rho_val, ...)
%
% 输入:
%   y           - (N x 1) 观测信号
%   n           - (标量) 趋势成分的阶数
%   gamma_trend - (标量, >0) 趋势成分的正则化参数
%
% 可选输入 (键值对):
%   'rho'       - (标量, >0) ADMM参数 (默认: 10.0)
%   'max_iter'  - (整数) 最大迭代次数 (默认: 100)
%   'tol'       - (标量) 收敛容忍度 (默认: 1e-4)
%
% 输出:
%   x_trend     - (N x 1) 恢复的趋势成分
%   x_periodic  - (N x 1) 恢复的周期-2干扰成分
%   x_noise     - (N x 1) 恢复的噪声成分
%
% 作者: Felix Heide (基于理论模型构建)

% --- 1. 解析输入参数 ---
p = inputParser;
addRequired(p, 'y', @isnumeric);
addRequired(p, 'n', @(x) isscalar(x) && x >= 0);
addRequired(p, 'gamma_trend', @(x) isscalar(x) && x > 0);
addParameter(p, 'rho', 10.0, @(x) isscalar(x) && x > 0);
addParameter(p, 'max_iter', 100, @(x) isscalar(x) && x > 0);
addParameter(p, 'tol', 1e-4, @(x) isscalar(x) && x > 0);
parse(p, y, n, gamma_trend, varargin{:});

rho = p.Results.rho;
max_iter = p.Results.max_iter;
tol_abs = p.Results.tol;

% --- 2. 初始化和预计算 ---
N = length(y);
y = y(:); % 确保是列向量

% a. 趋势成分预计算 (将在内部函数中处理)
% (无)

% b. 周期成分预计算
% 构建周期-2湮灭算子 A_p
Ap = spdiags([ones(N-1,1), ones(N-1,1)], [0, 1], N-1, N);
% **关键性能优化**: 预计算投影算子
% 我们需要求解 A_p*A_p' * w = b 形式的方程
% A_p*A_p' 是一个三对角矩阵，非常高效
L_Ap = chol(Ap * Ap', 'lower');
L_Ap_t = L_Ap';

% c. 初始化 ADMM 变量
% 使用合理的初始值进行热启动
x_trend = y;
x_periodic = zeros(N, 1);
x_noise = zeros(N, 1);

z_trend = x_trend;
z_periodic = x_periodic;
z_noise = x_noise;

u_trend = zeros(N, 1);
u_periodic = zeros(N, 1);
u_noise = zeros(N, 1);

fprintf('开始 ADMM 信号分解...\n');

% --- 3. ADMM 主循环 ---
for k = 1:max_iter
    
    % 存储旧值以检查收敛
    z_trend_old = z_trend;
    
    % a. 更新平均值和对偶变量的组合
    x_bar = (z_trend + z_periodic + z_noise) / 3;
    u_bar = (u_trend + u_periodic + u_noise) / 3;
    
    % b. 各成分的近端算子更新 (Proximal Updates)
    
    % i. 趋势成分更新 (调用 l1 趋势滤波器)
    v_trend = x_bar - u_bar + (y - x_bar) / 3;
    % **核对检查**: 这里的调用形式是关键。问题是 min 1/2||z-v||^2 + (gamma/rho)||Dz||_1
    z_trend = admm_trend_filter(v_trend, n, gamma_trend/rho, 'rho', 1.0, 'max_iter', 10); % 内部迭代不需要太多次
    
    % ii. 周期成分更新 (投影)
    v_periodic = x_bar - u_bar + (y - x_bar) / 3;
    % **核对检查**: 求解 A_p*z = 0 约束下的投影
    % z = v - Ap' * inv(Ap*Ap') * Ap * v
    temp = L_Ap_t \ (L_Ap \ (Ap * v_periodic)); % 高效求解
    z_periodic = v_periodic - Ap' * temp;
    
    % iii. 噪声成分更新 (软阈值)
    v_noise = x_bar - u_bar + (y - x_bar) / 3;
    % **核对检查**: 求解 min 1/2||z||^2 + rho/2||z-v||^2
    z_noise = (rho / (1 + rho)) * v_noise;
    
    % c. 对偶变量更新 (Dual Updates)
    u_trend = u_trend + (z_trend - (x_bar + (y - x_bar) / 3));
    u_periodic = u_periodic + (z_periodic - (x_bar + (y - x_bar) / 3));
    u_noise = u_noise + (z_noise - (x_bar + (y - x_bar) / 3));
    
    % d. 检查收敛条件
    % 使用变量的变化作为收敛判据
    change = norm(z_trend - z_trend_old) / norm(z_trend_old);
    if mod(k, 10) == 0
        fprintf('Iter %d: Relative Change = %.6f\n', k, change);
    end
    
    if change < tol_abs
        fprintf('在第 %d 次迭代收敛。\n', k);
        break;
    end
end

if k == max_iter
    fprintf('达到最大迭代次数 %d。\n', max_iter);
end

% --- 4. 分配最终结果 ---
x_trend = z_trend;
x_periodic = z_periodic;
x_noise = z_noise;

end
