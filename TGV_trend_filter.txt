% --- 1. 生成一个真正考验TGV的信号 ---
N = 500;
t = (1:N)';
% 包含: 分段常数(阶跃), 分段线性(斜坡), 分段二次(平滑曲线)
z_true = ...
    (t < 100) .* 2 + ...
    (t >= 100 & t < 250) .* (2 - 4/150 * (t - 100)) + ...
    (t >= 250 & t < 400) .* (-2 + 1.5 * ((t-250)/150).^2) + ...
    (t >= 400) .* (-0.5);

noise_level = 0.2;
z_hat_noisy = z_true + noise_level * randn(N, 1);

% --- 2. 参数调优指南与调用 ---
% alpha0: 控制“断点”的稀疏性。值越大，断点越少，信号越趋向于一个整体的多项式。
% alpha1: 控制“平滑度”。值越大，信号越趋向于分段线性。
% 关键是 alpha0/alpha1 的比率。通常 alpha0 > alpha1。

alpha0 = 20.0;  
alpha1 = 5.0;   

tic;
z_tgv = admm_tgv_filter_v2(z_hat_noisy, alpha0, alpha1);
toc;

% --- 3. 可视化 ---
figure('Name', 'TGV Filter v2 Results', 'NumberTitle', 'off');
set(gcf, 'color', 'w');
plot(z_hat_noisy, '.', 'Color', [0.7 0.7 0.9], 'DisplayName', 'Noisy');
hold on;
plot(z_true, 'k-', 'LineWidth', 3, 'DisplayName', 'True');
plot(z_tgv, 'b-', 'LineWidth', 1.5, 'DisplayName', 'TGV Filtered');
legend('show', 'Location', 'best');
title(sprintf('TGV Filter (\\alpha_0=%.1f, \\alpha_1=%.1f)', alpha0, alpha1));
grid on;

function z = admm_tgv_filter_v3(z_hat, alpha0, alpha1, varargin)
% ADMM_TGV_FILTER_V3 - (最终生产版) 求解二阶TGV趋势滤波问题
%
% 修正了V2版本中线性系统构建的致命符号错误。
% 增加了自适应rho机制以提高收敛速度和鲁棒性。
%
% 用法:
%   z = admm_tgv_filter_v3(z_hat, alpha0, alpha1, 'rho_init', val, ...)

% --- 1. 解析输入参数 ---
p = inputParser;
addRequired(p, 'z_hat', @isnumeric);
addRequired(p, 'alpha0', @(x) isscalar(x) && x > 0);
addRequired(p, 'alpha1', @(x) isscalar(x) && x > 0);
addParameter(p, 'rho_init', (alpha0+alpha1)/2, @(x) isscalar(x) && x > 0);
addParameter(p, 'max_iter', 500, @(x) isscalar(x) && x > 0);
addParameter(p, 'tol', 1e-5, @(x) isscalar(x) && x > 0);
addParameter(p, 'verbose', true, @islogical);
parse(p, z_hat, alpha0, alpha1, varargin{:});

rho = p.Results.rho_init;
max_iter = p.Results.max_iter;
tol_abs = p.Results.tol;
verbose = p.Results.verbose;

% ADMM自适应参数
mu = 10;
tau = 2;

% --- 2. 初始化和预计算 ---
N = length(z_hat);
z_hat = z_hat(:);

D1z = sparse(diff(eye(N), 1));
D1w = sparse(diff(eye(N-1), 1));

z = z_hat;
w = zeros(N - 1, 1);
u1 = zeros(N - 1, 1);
u2 = zeros(N - 2, 1);
y1 = zeros(N - 1, 1);
y2 = zeros(N - 2, 1);

if verbose, fprintf('开始 ADMM TGV滤波 (最终生产版 v3)...\n'); end

% --- 3. ADMM 主循环 ---
for k = 1:max_iter
    z_old = z;
    u1_old = u1;
    u2_old = u2;
    
    % a. (z, w)-update
    % 每次循环都需要重新构建和分解LHS，因为rho是变化的
    A11 = speye(N) + rho * (D1z' * D1z);
    A12 = -rho * D1z';
    A21 = -rho * D1z;
    A22 = rho * speye(N-1) + rho * (D1w' * D1w);
    LHS = [A11, A12; A21, A22];
    
    RHS_z = z_hat + rho * D1z' * (u1 - y1);
    %%% *** CRITICAL FIX HERE: Sign change from '+' to '-' *** %%%
    RHS_w = rho * (u1 - y1) - rho * D1w' * (u2 - y2);
    RHS = [RHS_z; RHS_w];
    
    % 使用Cholesky分解求解
    try
        R = chol(LHS);
        zw = R \ (R' \ RHS);
    catch
        if verbose, warning('Iter %d: Cholesky failed, using LU.', k); end
        [L_lu, U_lu, P_lu, Q_lu] = lu(LHS);
        zw = Q_lu * (U_lu \ (L_lu \ (P_lu * RHS)));
    end
    
    z = zw(1:N);
    w = zw(N+1:end);
    
    % b. u-updates (soft thresholding)
    D1z_val = D1z * z;
    u1 = soft_threshold(D1z_val - w + y1, alpha1 / rho);
    
    D1w_val = D1w * w;
    u2 = soft_threshold(D1w_val + y2, alpha0 / rho);
    
    % c. y-updates (dual variables)
    y1 = y1 + (D1z_val - w - u1);
    y2 = y2 + (D1w_val - u2);
    
    % d. 计算残差
    r_prim1 = norm(D1z_val - w - u1);
    r_prim2 = norm(D1w_val - u2);
    r_dual1 = norm(rho * D1z' * (u1 - u1_old));
    r_dual2 = norm(rho * (-(u1-u1_old) + D1w'*(u2-u2_old)));
    
    r_prim = sqrt(r_prim1^2 + r_prim2^2);
    r_dual = sqrt(r_dual1^2 + r_dual2^2);

    % e. 自适应 Rho 更新
    if r_prim > mu * r_dual
        rho = rho * tau;
    elseif r_dual > mu * r_prim
        rho = rho / tau;
    end
    
    % f. 检查收敛
    change = norm(z - z_old, 'fro') / (norm(z_old, 'fro') + 1e-12);
    if verbose && (mod(k, 50) == 0 || k == 1)
        fprintf('Iter %d: RelChg=%.2e, R_prim=%.2e, R_dual=%.2e, rho=%.2f\n', ...
            k, change, r_prim, r_dual, rho);
    end
    
    if change < tol_abs && k > 50 % 避免过早收敛
        if verbose, fprintf('在第 %d 次迭代收敛。\n', k); end
        break;
    end
end

if k == max_iter && verbose
    fprintf('达到最大迭代次数 %d。\n', max_iter);
end

end

function y = soft_threshold(x, lambda)
    y = max(0, x - lambda) - max(0, -x - lambda);
end
